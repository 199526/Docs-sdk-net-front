<Type Name="DiagnosticSource" FullName="System.Diagnostics.DiagnosticSource">
  <TypeSignature Language="C#" Value="public abstract class DiagnosticSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DiagnosticSource extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DiagnosticSource" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DiagnosticSource" />
  <TypeSignature Language="F#" Value="type DiagnosticSource = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class DiagnosticSource abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            This is the basic API to 'hook' parts of the framework.   It is like an EventSource
            (which can also write object), but is intended to log complex objects that can't be serialized.
            
            Please See the DiagnosticSource Users Guide 
            https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md
            for instructions on its use.  
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DiagnosticSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DiagnosticSource();" />
      <MemberSignature Language="C++ CX" Value="protected:&#xA; DiagnosticSource();" />
      <MemberSignature Language="C++ WINRT" Value=" DiagnosticSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public abstract bool IsEnabled (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsEnabled (name As String) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string -&gt; bool" Usage="diagnosticSource.IsEnabled name" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsEnabled(System::String ^ name);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract bool IsEnabled(Platform::String ^ name);" />
      <MemberSignature Language="C++ WINRT" Value=" abstract bool IsEnabled(std::wstring const &amp; name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the event being written.</param>
        <summary>
            Optional: if there is expensive setup for the notification, you can call IsEnabled
            before doing this setup.   Consumers should not be assuming that they only get notifications
            for which IsEnabled is true however, it is optional for producers to call this API. 
            The name should be the same as what is passed to Write.   
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool IsEnabled (string name, object arg1, object arg2 = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnabled (name As String, arg1 As Object, Optional arg2 As Object = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string * obj * obj -&gt; bool&#xA;override this.IsEnabled : string * obj * obj -&gt; bool" Usage="diagnosticSource.IsEnabled (name, arg1, arg2)" />
      <MemberSignature Language="C++ WINRT" Value=" virtual bool IsEnabled(std::wstring const &amp; name, winrt::Windows::Foundation::IInspectable const &amp; arg1, winrt::Windows::Foundation::IInspectable const &amp; arg2 = null);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of the event being written.</param>
        <param name="arg1">An object that represents the additional context for IsEnabled.
            Consumers should expect to receive null which may indicate that producer called pure 
            IsEnabled(string)  to check if consumer wants to get notifications for such events at all. 
            Based on it, producer may call IsEnabled(string, object, object) again with non-null context </param>
        <param name="arg2">Optional. An object that represents the additional context for IsEnabled. 
            Null by default. Consumers shoud expect to receive null which may indicate that producer 
            called pure IsEnabled(string) or producer passed all necessary context in arg1</param>
        <summary>
            Optional: if there is expensive setup for the notification, you can call IsEnabled
            before doing this setup with context 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (name As String, value As Object)" />
      <MemberSignature Language="F#" Value="abstract member Write : string * obj -&gt; unit" Usage="diagnosticSource.Write (name, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract void Write(Platform::String ^ name, Platform::Object ^ value);" />
      <MemberSignature Language="C++ WINRT" Value=" abstract void Write(std::wstring const &amp; name, winrt::Windows::Foundation::IInspectable const &amp; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of the event being written.</param>
        <param name="value">An object that represent the value being passed as a payload for the event.
            This is often a anonymous type which contains several sub-values.</param>
        <summary>
            Write is a generic way of logging complex payloads.  Each notification
            is given a name, which identifies it as well as a object (typically an anonymous type)
            that gives the information to pass to the notification, which is arbitrary.  
            
            The name should be short (so don't use fully qualified names unless you have to
            to avoid ambiguity), but you want the name to be globally unique.  Typically your componentName.eventName
            where componentName and eventName are strings less than 10 characters are a good compromise.  
            notification names should NOT have '.' in them because component names have dots and for them both
            to have dots would lead to ambiguity.   The suggestion is to use _ instead.  It is assumed 
            that listeners will use string prefixing to filter groups, thus having hierarchy in component 
            names is good.  
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>